\section{Sistemi di tipo}
\label{sec:3-1-type-systems}

Durante la genesi di ogni linguaggio di programmazione, una delle scelte più significative riguarda
l'introduzione di un sistema per gestire i tipi di variabili ed espressioni.

\noindent Tali sistemi di tipo sono di fatto insiemi di regole logiche che permettono
di assegnare una proprietà \textit{"type"} a ciascuno dei termini del linguaggio che ne necessitano.

\noindent Sono principalmente suddivisi in due categorie:
\begin{itemize}
      \item \textbf{tipizzazione statica}: i tipi sono definiti a tempo di compilazione
            e non possono cambiare mentre il programma è in esecuzione;
      \item \textbf{tipizzazione dinamica}: i tipi vengono stabiliti durante l'esecuzione
            e possono cambiare in qualsiasi momento.
\end{itemize}

\noindent Oltre a questa distinzione esistono varie sfumature e approcci differenti,
informalmente classificati in base alla rigidità delle regole di tipizzazione.
Si parla di \textit{tipizzazione debole} quando ad esempio sono consentite conversioni implicite tra tipi diversi,
\textit{tipizzazione forte} se sono impedite, oppure qualora sia o meno disponibile l'aritmetica dei puntatori.

\newpage

\begin{figure}
      \begin{tikzpicture}[scale=0.5, >={Stealth[width=1.5mm,length=2mm]}]
            % nodes instead of proper axis, less of a hassle
            \node (dynamic) at (-11,0) {Dinamico};
            \node (static) at (11,0) {Statico};
            \node (weak) at (0,-11) {Debole};
            \node (strong) at (0,11) {Forte};
            \draw[<->] (dynamic) -- (static);
            \draw[<->] (weak) -- (strong);
            % bleh
            \node at (-8,-5) {\texttt{Visual Basic}};
            \node at (-4,-8) {\texttt{JavaScript}};
            \node at (-8,-2) {\texttt{Perl}};
            \node at (-3,-3) {\texttt{PHP}};
            % meh
            \node at (-7,8) {\texttt{Erlang}};
            \node at (-8,5) {\texttt{Clojure}};
            \node at (-3,7) {\texttt{Groovy}};
            \node at (-6,3) {\texttt{Python}};
            \node at (-2,2) {\texttt{Ruby}};
            % okay
            \node at (3,-4) {\texttt{C}};
            \node at (6,-6) {\texttt{C++}};
            % good
            \node at (3,7) {\texttt{C\#}};
            \node at (4,1) {\texttt{Funx}}; % bleh amongst the good
            \node at (5,4) {\texttt{Java}};
            \node at (2,3) {\texttt{F\#}};
            \node at (7,6) {\texttt{Scala}};
            \node at (8,2) {\texttt{Haskell}}; % hell yeah
            \node at (8,8) {\texttt{Rust}}; % divine
      \end{tikzpicture}
      \caption{Alcuni linguaggi e loro sistemi di tipo}
      \label{fig:3-1-languages-type-systems}
      \vspace{4mm}
\end{figure}

\noindent Grazie ai tipi dinamici, linguaggi quali \texttt{Python} e \texttt{JavaScript} permettono
veloce prototipazione, flessibilità e codice più conciso, a discapito però di una più alta
probabilità d'incontrare errori importanti a runtime, piuttosto che in fase di compilazione.


Al contrario, i tipi statici spesso migliorano naturalmente la mantenibilità di un progetto:
viene limitata la possibilità di scorciatoie nello sviluppo, ma si hanno maggiori garanzie di correttezza,
in quanto il compilatore può implementare ulteriori controlli e segnalare errori semantici più precisi già
prima dell'esecuzione del programma.

\noindent D'altro canto, l'obbligo di specificare i tipi di ogni variabile, oggetto, funzione e
parametro può risultare tedioso e talvolta ridondante; molti linguaggi moderni,
tra cui \texttt{Haskell}, ovviano a quest'inconvenienza tramite l'uso dell'inferenza di tipo.

\noindent Gli algoritmi d'inferenza introducono numerosi benefici, in particolare:
\begin{itemize}
      \item la scrittura del codice è meno onerosa per lo sviluppatore a prescindere dal sistema di tipi utilizzato,
            e diviene quindi estremamente vantaggioso utilizzare tipi statici;
      \item le annotazioni ora opzionali possono essere aggiunte dal programmatore quando vi sono casi difficili
            da disambiguare automaticamente, oppure per migliorare la leggibilità del codice;
      \item gli strumenti di sviluppo per il linguaggio possono sfruttare informazioni fornite dal motore inferenziale
            per suggerire il tipo delle espressioni e arricchire i messaggi di errore e di warning.
\end{itemize}

\newpage

\input{3-inference/3-2-lambda-cube.tex}

\input{3-inference/3-3-system-fc.tex}